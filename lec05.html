<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>lec05</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a id="lab1"></a><h1 class="section">Лекция 5. Лямбда-исчисление с простыми и зависимыми типами. Соответствие Карри-Говарда</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Nat</span> <span class="id" title="var">Peano</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab2"></a><h2 class="section">Бестиповое лямбда-исчисление (напоминание материала прошлого семестра)</h2>


<div class="paragraph"> </div>

Термы определяются грамматикой <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">::=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>.

<div class="paragraph"> </div>

Термы вида <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">N</span></span> называются аппликацией, а <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> —
(лямбда-)абстракцией. Терм <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> определяет анонимную
функцию с формальным параметром (аргументом) <span class="inlinecode"><span class="id" title="var">x</span></span> и телом <span class="inlinecode"><span class="id" title="var">M</span></span>.
В Coq терм <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> записывается <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">M</span></span>.

<div class="paragraph"> </div>

Аппликации группируется налево: <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">N</span></span> <span class="inlinecode"><span class="id" title="var">K</span></span> есть <span class="inlinecode">(<span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="var">N</span>)</span> <span class="inlinecode"><span class="id" title="var">K</span></span>.
Запись <span class="inlinecode"><span class="id" title="var">λx</span></span> <span class="inlinecode"><span class="id" title="var">y</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> есть сокращение для <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">λy</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>.

<div class="paragraph"> </div>

Переменная <span class="inlinecode"><span class="id" title="var">x</span></span> считается связанной в терме <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>. Связанные
переменные можно свободно переименовывать. Выражение <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>
ведет себя во многом также, как <span class="inlinecode">∀<span class="id" title="var">x</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> или <span class="inlinecode">∃<span class="id" title="var">x</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>.

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">M</span>[<span class="id" title="var">N</span>/<span class="id" title="var">x</span>]</span> обозначает подстановку терма <span class="inlinecode"><span class="id" title="var">N</span></span> в терм <span class="inlinecode"><span class="id" title="var">M</span></span> вместо свободных
вхождений переменной <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

β-редукция: <span class="inlinecode">(<span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span>)</span> <span class="inlinecode"><span class="id" title="var">N</span></span> →<sub>β</sub> <span class="inlinecode"><span class="id" title="var">M</span>[<span class="id" title="var">N</span>/<span class="id" title="var">x</span>]</span>. Это означает,
что терм <span class="inlinecode">(<span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span>)</span> <span class="inlinecode"><span class="id" title="var">N</span></span> переписывается в <span class="inlinecode"><span class="id" title="var">M</span>[<span class="id" title="var">N</span>/<span class="id" title="var">x</span>]</span>. Бета-редукция есть
бинарное отношение на термах.

<div class="paragraph"> </div>

Смысл: если функция, представляемая термом <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span>, применяется
к фактическому параметру <span class="inlinecode"><span class="id" title="var">N</span></span>, то шаг вычисления состоит в подстановке
фактического параметра вместо формального параметра <span class="inlinecode"><span class="id" title="var">x</span></span> в тело функции.

<div class="paragraph"> </div>

В Coq есть еще несколько типов редукций: они обозначаются буквами δ, ζ и ι.

<div class="paragraph"> </div>

<ul class="doclist">
<li> δ-редукция разворачивает определения. Например, определение

</li>
</ul>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="var">sqr</span>(<span class="id" title="var">x</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">x</span> * <span class="id" title="var">x</span>.
<div class="paragraph"> </div>

</span>добавляет правило <span class="inlinecode"><span class="id" title="var">sqr</span></span> <span class="inlinecode">2</span> →<sub>δ</sub> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode">2</span>.

<div class="paragraph"> </div>

<ul class="doclist">
<li> ζ-редукция отвечает за <span class="inlinecode"><span class="id" title="keyword">let</span></span>.

</li>
</ul>

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">N</span></span> →<sub>ζ</sub> <span class="inlinecode"><span class="id" title="var">N</span>[<span class="id" title="var">M</span>/<span class="id" title="var">x</span>]</span>

<div class="paragraph"> </div>

<ul class="doclist">
<li> ι-редукция разворачивает рекурсивные определения и <span class="inlinecode"><span class="id" title="keyword">match</span></span>. Как

</li>
</ul>
отмечалось в лекции 3, определение

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">plus</span> (<span class="id" title="var">m</span> <span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">m</span> <span class="id" title="keyword">with</span><br/>
| 0 =&gt; <span class="id" title="var">n</span><br/>
| <span class="id" title="var">S</span> <span class="id" title="var">m'</span> =&gt; <span class="id" title="var">S</span> (<span class="id" title="var">plus</span> <span class="id" title="var">m'</span> <span class="id" title="var">n</span>)<br/>
<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>добавляет правила <span class="inlinecode">0</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> →<sub>ι</sub> <span class="inlinecode"><span class="id" title="var">n</span></span> и <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span> →<sub>ι</sub> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode">(<span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>.

<div class="paragraph"> </div>

Каждую редукцию можно проводить также в глубине терма. Рефлексивное,
симметричное и транзитивное замыкание объединения редукций есть
равенство по определению (см. лекцию 3). С точки зрения Coq термы,
получающиеся друг из друга цепочкой переписываний согласно правилам
редукций, представляют собой один и тот же терм.

<div class="paragraph"> </div>

Равенство по определению широко используется в тактике <span class="inlinecode"><span class="id" title="tactic">apply</span></span>. Так,
рассмотрим ситуацию, когда в контексте есть посылка <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A2</span></span> <span class="inlinecode">→</span>
<span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">t</span>/<span class="id" title="var">x</span>]</span>, а целью является формула <span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">s</span>/<span class="id" title="var">x</span>]</span>. Тактика <span class="inlinecode"><span class="id" title="tactic">apply</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span>
автоматически определяет, равны ли <span class="inlinecode"><span class="id" title="var">s</span></span> и <span class="inlinecode"><span class="id" title="var">t</span></span> по определению, и в этом
случае порождает цели <span class="inlinecode"><span class="id" title="var">A1</span></span> и <span class="inlinecode"><span class="id" title="var">A2</span></span>. В дополнение к этому, как
говорилось в лекции 4, тактика <span class="inlinecode"><span class="id" title="tactic">apply</span></span> может осуществлять унификацию.
Чтобы это работало, равенство по определению должно быть разрешимым.
Именно поэтому оно выделено как разрешимое подмножество
пропозиционального равенства. 
<div class="paragraph"> </div>

 Пример в лекции 7, слайды 10-11 из предыдущего семестра про
представление пар в чистом лямбда-исчислении. Эти слайды добавлены на
<a href="https://source.unn.ru">source.unn.ru</a>. На типы,
указанные в фигурных скобках и после двоеточий, можно пока не обращать
внимание. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Reductions</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">Pair</span> {<span class="id" title="var">P</span>} := (<span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">P</span>) → <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">pair</span> {<span class="id" title="var">P</span>} (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">y</span> : <span class="id" title="var">B</span>) := <span class="id" title="keyword">fun</span> <span class="id" title="var">f</span> =&gt; <span class="id" title="var">f</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="var">P</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">fst</span> (<span class="id" title="var">p</span> : <span class="id" title="var">Pair</span>) := <span class="id" title="var">p</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">snd</span> (<span class="id" title="var">p</span> : <span class="id" title="var">Pair</span>) := <span class="id" title="var">p</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> =&gt; <span class="id" title="var">y</span>).<br/>

<br/>
<span class="id" title="keyword">Variables</span> (<span class="id" title="var">m</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">B</span>).<br/>

<br/>
</div>

<div class="doc">
Команда <span class="inlinecode"><span class="id" title="keyword">Compute</span></span> находит нормальную форму терма. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">fst</span> (<span class="id" title="var">pair</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">snd</span> (<span class="id" title="var">pair</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Reductions</span>.<br/>

<br/>
</div>

<div class="doc">
В отличие от языков функционального программирования, таких как Racket,
которые могут работать только с замкнутыми выражениями, Coq может
упрощать термы со свободными переменными (в данном случае <span class="inlinecode"><span class="id" title="var">m</span></span> и <span class="inlinecode"><span class="id" title="var">n</span></span>). 
<div class="paragraph"> </div>

<a id="lab3"></a><h2 class="section">Лямбда-исчисление с простыми типами</h2>


<div class="paragraph"> </div>

Типы определяются грамматикой <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">::=</span> <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Здесь <span class="inlinecode"><span class="id" title="var">b</span></span> пробегает
по множество базовых типов (например, <span class="inlinecode"><span class="id" title="var">nat</span></span>, <span class="inlinecode"><span class="id" title="var">bool</span></span>, <span class="inlinecode"><span class="id" title="var">int</span></span>, <span class="inlinecode"><span class="id" title="var">string</span></span>).
Пример типа: <span class="inlinecode">(<span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">string</span></span>.

<div class="paragraph"> </div>

В тИповом исчислении вместо терма <span class="inlinecode"><span class="id" title="var">λx</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> пишется <span class="inlinecode"><span class="id" title="var">λx</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> (добавляется
тип формального параметра).

<div class="paragraph"> </div>

Не все термы бестипового исчисления имеют смысл с точки зрения типов.
Например, <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> есть терм, но если <span class="inlinecode"><span class="id" title="var">x</span></span> представляет функцию из <span class="inlinecode"><span class="id" title="var">A</span></span> в
<span class="inlinecode"><span class="id" title="var">B</span></span>, то аргумент <span class="inlinecode"><span class="id" title="var">x</span></span> должен иметь тип <span class="inlinecode"><span class="id" title="var">A</span></span>, что приводит к уравнению на
типы <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. У этого уравнения нет конечных решений.

<div class="paragraph"> </div>

<a id="lab4"></a><h3 class="section">Правила вывода</h3>


<div class="paragraph"> </div>

Типовый контекст <span class="inlinecode"><span class="id" title="var">Γ</span></span> есть последовательность <span class="inlinecode"><span class="id" title="var">x1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A1</span>,</span> <span class="inlinecode"><span class="id" title="var">x2</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A2</span>,</span> <span class="inlinecode">...,</span>
<span class="inlinecode"><span class="id" title="var">xn</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">An</span></span>, где <span class="inlinecode"><span class="id" title="var">xi</span></span> — переменные, <span class="inlinecode"><span class="id" title="var">Ai</span></span> — типы. Таким образом, контекст
можно рассматривать как присваивание типов свободным переменным <span class="inlinecode"><span class="id" title="var">x1</span>,</span>
<span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">xn</span></span>. Для исчисления с простыми типами контекст можно также
рассматривать как множество, но для зависимых типов, рассматриваемых
далее, последовательность переменных будет важна.

<div class="paragraph"> </div>

Выводимые суждения имеют вид <span class="inlinecode"><span class="id" title="var">Γ</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, где <span class="inlinecode"><span class="id" title="var">M</span></span> — терм, <span class="inlinecode"><span class="id" title="var">A</span></span> — тип.
Для правил ниже выполняется утверждение: если <span class="inlinecode"><span class="id" title="var">Γ</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> выводится,
то все свободные переменные терма <span class="inlinecode"><span class="id" title="var">M</span></span> встречаются в <span class="inlinecode"><span class="id" title="var">Γ</span></span>. Смысл
суждения таков: если свободные переменные в <span class="inlinecode"><span class="id" title="var">M</span></span> имеют типы, как
указано в <span class="inlinecode"><span class="id" title="var">Γ</span></span>, то терм <span class="inlinecode"><span class="id" title="var">M</span></span> имеет тип <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

Аксиома: <span class="inlinecode"><span class="id" title="var">Γ</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">(<span class="id" title="var">Var</span>)</span>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span>, <span class="id" title="var">x</span> : <span class="id" title="var">A</span> |- <span class="id" title="var">M</span> : <span class="id" title="var">B</span><br/>
-------------------------------- (<span class="id" title="var">Abs</span>)<br/>
<span class="id" title="var">Γ</span> |- (<span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">M</span>) : <span class="id" title="var">A</span> → <span class="id" title="var">B</span><br/>
<br/>
<span class="id" title="var">Γ</span> |- <span class="id" title="var">M</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>     <span class="id" title="var">Γ</span> |- <span class="id" title="var">N</span> : <span class="id" title="var">A</span><br/>
------------------------------- (<span class="id" title="var">App</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">M</span> <span class="id" title="var">N</span> : <span class="id" title="var">B</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<a id="lab5"></a><h4 class="section">Обозначение в Coq</h4>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="var">λx</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">M</span></span> записывается <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">M</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">SimpleTypes</span>.<br/>

<br/>
<span class="id" title="keyword">Variables</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">
Примеры замкнутых типизируемых термов

<div class="paragraph"> </div>

1. Тождественная функция 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Печатается <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span> 
<div class="paragraph"> </div>

 2. Функция, которая принимает <span class="inlinecode"><span class="id" title="var">x</span></span> и возвращает функцию-константу,
возвращающую <span class="inlinecode"><span class="id" title="var">x</span></span> независимо от аргумента <span class="inlinecode"><span class="id" title="var">y</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> : <span class="id" title="var">A</span> =&gt; <span class="id" title="keyword">fun</span> <span class="id" title="var">y</span> : <span class="id" title="var">B</span> =&gt; <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
Печатается <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span>. Напоминание: <span class="inlinecode">→</span> правоассоциативна. 
<div class="paragraph"> </div>

 Идущие подряд лямбда абстракции можно объединить.
Несущественные переменные можно заменять на _.
Поэтому предыдущий терм можно записать как <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode">(<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">(<span class="id" title="var">_</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">x</span></span>. 
<div class="paragraph"> </div>

 3. Оператор, принимающий <span class="inlinecode"><span class="id" title="var">f</span></span> и <span class="inlinecode"><span class="id" title="var">g</span></span> и возвращающий их композицию 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> (<span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) (<span class="id" title="var">g</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>).<br/>

<br/>
</div>

<div class="doc">
Печатается <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span></span> 
<div class="paragraph"> </div>

 Тип <span class="inlinecode"><span class="id" title="var">g</span></span> можно опустить, потому что из <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> следует,
что <span class="inlinecode"><span class="id" title="var">g</span></span> принимает аргумент типа <span class="inlinecode"><span class="id" title="var">A</span></span> и возвращает значение типа <span class="inlinecode"><span class="id" title="var">B</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">fun</span> (<span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) <span class="id" title="var">g</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) =&gt; <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>).<br/>

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">SimpleTypes</span>.<br/>

<br/>
</div>

<div class="doc">
Построим выводы суждений о типах для трех функций выше.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;--------------- (<span class="id" title="var">Var</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">x</span> : <span class="id" title="var">A</span> |- <span class="id" title="var">x</span> : <span class="id" title="var">A</span><br/>
----------------------- (<span class="id" title="var">Abs</span>)<br/>
|- (<span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">x</span>) : <span class="id" title="var">A</span> → <span class="id" title="var">A</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;--------------------- (<span class="id" title="var">Var</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">y</span> : <span class="id" title="var">B</span> |- <span class="id" title="var">x</span> : <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;---------------------------- (<span class="id" title="var">Abs</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">x</span> : <span class="id" title="var">A</span> |- (<span class="id" title="var">λy</span> : <span class="id" title="var">B</span>. <span class="id" title="var">x</span>) : <span class="id" title="var">B</span> → <span class="id" title="var">A</span><br/>
------------------------------------ (<span class="id" title="var">Abs</span>)<br/>
|- (<span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">λy</span> : <span class="id" title="var">B</span>. <span class="id" title="var">x</span>) : <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">A</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

В следующем выводе Γ обозначает контекст <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>,</span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span>.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-------------- (<span class="id" title="var">Var</span>)  --------- (<span class="id" title="var">Var</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">g</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>        <span class="id" title="var">Γ</span> |- <span class="id" title="var">x</span> : <span class="id" title="var">A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;--------------- (<span class="id" title="var">Var</span>)   --------------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>                <span class="id" title="var">Γ</span> |- <span class="id" title="var">g</span> <span class="id" title="var">x</span> : <span class="id" title="var">B</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;-------------------------------------------- (<span class="id" title="var">App</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>, <span class="id" title="var">g</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>, <span class="id" title="var">x</span> : <span class="id" title="var">A</span> |- <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) : <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;---------------------------------------------------- (<span class="id" title="var">Abs</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>, <span class="id" title="var">g</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span> |- <span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) : <span class="id" title="var">A</span> → <span class="id" title="var">C</span><br/>
----------------------------------------------------------- (<span class="id" title="var">Abs</span>)<br/>
<span class="id" title="var">f</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span> |- <span class="id" title="var">λg</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>. <span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) : (<span class="id" title="var">A</span> → <span class="id" title="var">B</span>) → <span class="id" title="var">A</span> → <span class="id" title="var">C</span><br/>
----------------------------------------------------------- (<span class="id" title="var">Abs</span>)<br/>
|- <span class="id" title="var">λf</span> : <span class="id" title="var">B</span> → <span class="id" title="var">C</span>. <span class="id" title="var">λg</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>. <span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">B</span> → <span class="id" title="var">C</span>) → (<span class="id" title="var">A</span> → <span class="id" title="var">B</span>) → <span class="id" title="var">A</span> → <span class="id" title="var">C</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<a id="lab6"></a><h2 class="section">Соответствие Карри-Говарда</h2>


<div class="paragraph"> </div>

Типы замкнутых термов (то есть тип <span class="inlinecode"><span class="id" title="var">A</span></span> в выводимом суждении <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">:</span>
<span class="inlinecode"><span class="id" title="var">A</span></span>) есть тавтологии пропозициональной логики, если <span class="inlinecode">→</span> рассматривать
как импликацию, а базовые типы — как пропозициональные переменные. Это
потому, что если в правилах вывода стереть термы и оставить только
типы, то полученные правила будут корректны с точки зрения логики.

<div class="paragraph"> </div>

Правило

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">Γ</span> |- <span class="id" title="var">A</span><br/>
------<br/>
<span class="id" title="var">Δ</span> |- <span class="id" title="var">B</span>
<div class="paragraph"> </div>

</span>называется корректным, если из <span class="inlinecode"><span class="id" title="var">Γ</span></span> <span class="inlinecode">|=</span> <span class="inlinecode"><span class="id" title="var">A</span></span> следует <span class="inlinecode"><span class="id" title="var">Δ</span></span> <span class="inlinecode">|=</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

Действительно, если из правил вывода, приведенных выше, стереть термы, то получится следующее.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">Γ</span>, <span class="id" title="var">A</span> |- <span class="id" title="var">A</span> (<span class="id" title="var">Var</span>)<br/>
<br/>
&nbsp;<span class="id" title="var">Γ</span>, <span class="id" title="var">A</span> |- <span class="id" title="var">B</span><br/>
------------ (<span class="id" title="var">Abs</span>)<br/>
<span class="id" title="var">Γ</span> |- <span class="id" title="var">A</span> → <span class="id" title="var">B</span><br/>
<br/>
<span class="id" title="var">Γ</span> |- <span class="id" title="var">A</span> → <span class="id" title="var">B</span>     <span class="id" title="var">Γ</span> |- <span class="id" title="var">A</span><br/>
---------------------- (<span class="id" title="var">App</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">B</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Это правила натурального вывода пропозициональной логики.

<div class="paragraph"> </div>

Не все тавтологии, даже содержащие только <span class="inlinecode">→</span>, получаются как типы
замкнутых термов. Пример: формула Пирса <span class="inlinecode">((<span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span> (проверьте,
что это тавтология). Для вывода этой формулы не хватает снятия двойного
отрицания, например, правила

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">Γ</span> |- (<span class="id" title="var">A</span> → <span class="id" title="var">False</span>) → <span class="id" title="var">False</span><br/>
--------------------------<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">A</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Добавление в лямбда-исчисление конструкций, которые приблизили его
к классической логике — интересная и довольно новая тема исследований.

<div class="paragraph"> </div>

Описанное выше соответствие между лямбда-исчислением и логикой
называется соответствием (изоморфизмом) Карри-Говарда. Согласно этому
соответствию

<div class="paragraph"> </div>

типы = формулы (теоремы)

<div class="paragraph"> </div>

термы = доказательства теорем

<div class="paragraph"> </div>

Coq построен на соответствии Карри-Говарда. Его можно рассматривать
как язык функционального программирования (то есть язык, основанный на
лямбда-исчислении) с очень выразительной системой типов, а можно — как
систему доказательства теорем. Поиск доказательства = построение терма
с данным типом.

<div class="paragraph"> </div>

<a id="lab7"></a><h2 class="section">Лямбда-исчисление с зависимыми типами</h2>


<div class="paragraph"> </div>

В исчислении с простыми типами типы являются атомарными (неделимыми)
объектами. В исчислении с зависимыми типами термы могут входить в
типы. На самом деле, в Coq все выражения считаются термами. Некоторые
из них также являются типами, например, <span class="inlinecode"><span class="id" title="var">nat</span></span>, или типами типов,
например, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> или <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, поскольку <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. Типы типов
называются также сортами.

<div class="paragraph"> </div>

Пример зависимого типа: <span class="inlinecode">1</span> <span class="inlinecode">≤</span> <span class="inlinecode">2</span>, то есть <span class="inlinecode"><span class="id" title="var">le</span></span> <span class="inlinecode">1</span> <span class="inlinecode">2</span> без использования
обозначений. Здесь 1 и 2 — термы. Существует замкнутый тип
(доказательство) <span class="inlinecode"><span class="id" title="var">M</span></span>, такой что суждение <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">:</span> <span class="inlinecode">1</span> <span class="inlinecode">≤</span> <span class="inlinecode">2</span> выводимо. Другой
пример: существует терм <span class="inlinecode"><span class="id" title="var">N</span></span> со свободными переменными <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">y</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span>, такой что
суждение <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">N</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> выводимо.
(Замечание: порядок в контексте слева от <span class="inlinecode">|-</span> теперь важен.)

<div class="paragraph"> </div>

<a id="lab8"></a><h3 class="section">Правила вывода</h3>


<div class="paragraph"> </div>

Аксиома: <span class="inlinecode"><span class="id" title="var">Γ</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">(<span class="id" title="var">Var</span>)</span>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span>, <span class="id" title="var">x</span> : <span class="id" title="var">A</span> |- <span class="id" title="var">M</span> : <span class="id" title="var">B</span><br/>
----------------------------- (<span class="id" title="var">Abs</span>)<br/>
<span class="id" title="var">Γ</span> |- (<span class="id" title="var">λx</span> : <span class="id" title="var">A</span>, <span class="id" title="var">M</span>) : ∀<span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">B</span><br/>
<br/>
<span class="id" title="var">Γ</span> |- <span class="id" title="var">M</span> : ∀<span class="id" title="var">x</span> : <span class="id" title="var">A</span>, <span class="id" title="var">B</span>    <span class="id" title="var">Γ</span> |- <span class="id" title="var">N</span> : <span class="id" title="var">A</span><br/>
--------------------------------- (<span class="id" title="var">App</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">Γ</span> |- <span class="id" title="var">M</span> <span class="id" title="var">N</span> : <span class="id" title="var">B</span>[<span class="id" title="var">N</span>/<span class="id" title="var">x</span>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Здесь важно, что здесь <span class="inlinecode"><span class="id" title="var">x</span></span> может входить в тип <span class="inlinecode"><span class="id" title="var">B</span></span>. Тип <span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>,
где <span class="inlinecode"><span class="id" title="var">x</span></span> может входить в <span class="inlinecode"><span class="id" title="var">B</span></span>, называется зависимым произведением. Термы
этого типа — это функции с областью определения <span class="inlinecode"><span class="id" title="var">A</span></span>. Область значений
<span class="inlinecode"><span class="id" title="var">B</span></span> может зависит от <span class="inlinecode"><span class="id" title="var">x</span></span>. Если <span class="inlinecode"><span class="id" title="var">f</span></span> имеет тип <span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, то <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">M</span></span>
имеет тип <span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">N</span>/<span class="id" title="var">x</span>]</span> для любого терма <span class="inlinecode"><span class="id" title="var">M</span></span>. Таким образом, область
значений функции разбивается на подобласти для каждого значения типа
<span class="inlinecode"><span class="id" title="var">A</span></span>, и каждое такое значение отображается функцией <span class="inlinecode"><span class="id" title="var">f</span></span> в свою
подобласть. Например, пусть тип <span class="inlinecode"><span class="id" title="var">string</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> состоит из всех строк длины
<span class="inlinecode"><span class="id" title="var">n</span></span>. Тогда функция <span class="inlinecode"><span class="id" title="var">replicate</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">char</span></span> <span class="inlinecode">→</span> <span class="inlinecode">∀<span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">string</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> имеет два
аргумента: (скажем) <span class="inlinecode"><span class="id" title="var">c</span></span> типа <span class="inlinecode"><span class="id" title="var">char</span></span> и <span class="inlinecode"><span class="id" title="var">n</span></span> типа <span class="inlinecode"><span class="id" title="var">nat</span></span>. Она возвращает
строчку, состоящую из <span class="inlinecode"><span class="id" title="var">n</span></span> символов <span class="inlinecode"><span class="id" title="var">c</span></span>. Так, <span class="inlinecode"><span class="id" title="var">replicate</span></span> <span class="inlinecode">'<span class="id" title="var">a'</span></span> <span class="inlinecode">5</span> имеет
тип <span class="inlinecode"><span class="id" title="var">string</span></span> <span class="inlinecode">5</span>.

<div class="paragraph"> </div>

Как и в случае с простыми типами, правила вывода выше являются корректными
с точки зрения логики, если в них убрать переменные из контекста и терм
справа от штопора. Таким образом, соответствие Карри-Говарда распространяется
на предикатную логику.

<div class="paragraph"> </div>

Почему <span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">B</span></span> называется зависимым <em>произведением</em>? Это основано на
следующем факте из теории множеств. Пусть <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode">{1,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">n</span>}</span> и пусть <span class="inlinecode"><span class="id" title="var">A</span></span>
<span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> обозначает множество всех функций из <span class="inlinecode"><span class="id" title="var">A</span></span> в <span class="inlinecode"><span class="id" title="var">B</span></span> (также
обозначается через <span class="inlinecode"><span class="id" title="var">B</span>^<span class="id" title="var">A</span></span>, так как <span class="inlinecode">|<span class="id" title="var">B</span>^<span class="id" title="var">A</span>|</span> <span class="inlinecode">=</span> <span class="inlinecode">|<span class="id" title="var">B</span>|^|<span class="id" title="var">A</span>|</span>). Тогда существует
взаимно-однозначное соответствие между декартовым произведением <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>
<span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">B</span></span> (<span class="inlinecode"><span class="id" title="var">n</span></span> раз) и <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span>. Действительно, каждую функцию из <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span>
можно рассматривать как кортеж <span class="inlinecode"><span class="id" title="var">f</span>(1),</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">f</span>(<span class="id" title="var">n</span>)</span> элементов <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

Это соответствие имеет место и для бесконечных множество <span class="inlinecode"><span class="id" title="var">A</span></span>. Поэтому
множество функций <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> можно рассматривать как в общем случае
бесконечное декартово произведение копий <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

Что будет, если рассмотреть произведение различных множеств <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">B2</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">...</span>,
где индексы при <span class="inlinecode"><span class="id" title="var">B</span></span> пробегают по множеству <span class="inlinecode"><span class="id" title="var">A</span></span>? Ему соответствует множество
функций с областью определения <span class="inlinecode"><span class="id" title="var">A</span></span>, которые для каждого <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">A</span></span> принимают
значение из <span class="inlinecode"><span class="id" title="var">Bi</span></span>, то есть область значения которых зависит от аргумента.
Как было сказано выше, это множество обозначается <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span>.

<div class="paragraph"> </div>

Отсюда следует, что <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> есть частный случай <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>,
когда <span class="inlinecode"><span class="id" title="var">B</span></span> не зависит от <span class="inlinecode"><span class="id" title="var">x</span></span>. И действительно, в Coq тип <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> есть
сокращение для <span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, где <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">∉</span> <span class="inlinecode"><span class="id" title="var">FV</span>(<span class="id" title="var">B</span>)</span>.

<div class="paragraph"> </div>

<a id="lab9"></a><h4 class="section">Обозначение в Coq</h4>


<div class="paragraph"> </div>

<span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">B</span></span> записывается <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>.

<div class="paragraph"> </div>

Тип часто можно не указывать (<span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=&gt;</span> <span class="inlinecode"><span class="id" title="var">M</span></span> и <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>), и Coq
восстанавливает его из контекста, но иногда он все-таки нужен. 
<div class="paragraph"> </div>

 Кроме сорта <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, термами которого являются теоремы, в Coq есть
тип <span class="inlinecode"><span class="id" title="var">bool</span></span> с константами <span class="inlinecode"><span class="id" title="var">true</span></span> и <span class="inlinecode"><span class="id" title="var">false</span></span>. В отличие от <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, его
можно использовать в программах. Более подробно он будет
рассматриваться в следующей лекции.

<div class="paragraph"> </div>

Также в Coq есть тип <span class="inlinecode"><span class="id" title="var">unit</span></span> с единственным элементом <span class="inlinecode"><span class="id" title="var">tt</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">bool</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">unit</span>.<br/>

<br/>
</div>

<div class="doc">
Построим пример зависимого произведения и соответствующего терма. 
<div class="paragraph"> </div>

 Семейство из двух типов: B true = nat и B false = unit. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">B</span> (<span class="id" title="var">b</span> : <span class="id" title="var">bool</span>) :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
| <span class="id" title="var">true</span> =&gt; <span class="id" title="var">nat</span><br/>
| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">unit</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">B</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">B</span> <span class="id" title="var">false</span>.<br/>

<br/>
</div>

<div class="doc">
Терм, тип которого является зависимым произведением 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">dependent_type_function</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">b</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">B</span> <span class="id" title="var">b</span> :=<br/>
<span class="id" title="keyword">fun</span> <span class="id" title="var">b</span> =&gt;<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">b</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" title="var">true</span> =&gt; 5<br/>
&nbsp;&nbsp;| <span class="id" title="var">false</span> =&gt; <span class="id" title="var">tt</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab10"></a><h3 class="section">Использование соответствия Карри-Говарда в доказательствах</h3>


<div class="paragraph"> </div>

Как было сказано в лекции 1, цель, показанная в правом верхнем окне
CoqIDE, есть суждение, где горизонтальная черта обозначает штопор <span class="inlinecode">|-</span>.
Сверху от черты находится контекст, а снизу — цель в узком смысле слова.
Таким образом, например, <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">x</span></span> сверху от черты
означает посылку, а <span class="inlinecode"><span class="id" title="var">H</span></span> является не только названием этой посылки для
использования в тактиках, но и переменной, имеющей зависимый тип
<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">x</span></span>. Команда <span class="inlinecode"><span class="id" title="keyword">Check</span></span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">5</span> (с точкой в конце) показывает,
что терм <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">5</span> имеет тип <span class="inlinecode">5</span> <span class="inlinecode">≤</span> <span class="inlinecode">5</span>. Эту формулу можно добавить к посылкам
тактикой <span class="inlinecode"><span class="id" title="tactic">assert</span></span> <span class="inlinecode">(<span class="id" title="var">H1</span></span> <span class="inlinecode">:=</span> <span class="inlinecode"><span class="id" title="var">H</span></span> <span class="inlinecode">5)</span>. Также можно использовать любые теоремы из
стандартной библиотеки. Например, <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> имеет тип <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span>
<span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">n</span></span>, а <span class="inlinecode"><span class="id" title="var">plus_comm</span></span> <span class="inlinecode">1</span> <span class="inlinecode">2</span> имеет тип <span class="inlinecode">1</span> <span class="inlinecode">+</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span> <span class="inlinecode">+</span> <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

Таким образом, цель в правом верхнем окне CoqIDE, показывает
переменные с их типами над горизонтальной линией, а также тип, терм
которого нужно построить, или, эквивалентно, теорему, доказательство
которой нужно написать.

<div class="paragraph"> </div>

Лямбда-исчисление с типами (особенно с зависимыми) называется теорией
типов. Оно служит математическим основанием Coq и многих других
автоматизированных систем доказательств. Теория типов, где из общего
пропозиционального равенства выделено разрешимое равенство по
определению, называется интенсиональной. В ней система может
автоматически проверить, имеет ли данный терм некоторый тип и найти
этот тип. Теория типов, где есть только пропозициональное равенство,
называется экстенсиональной. Проверка типизируемости в ней
неразрешима, но некоторые математические конструкции записываются
более просто. 
<div class="paragraph"> </div>

<a id="lab11"></a><h3 class="section">Пример использования соответствия Карри-Говарда в доказательстве (теорема из лекции 4)</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">lt_S_r</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>, <span class="id" title="var">m</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">n</span> → <span class="id" title="var">m</span> = <span class="id" title="var">n</span> ∨ <span class="id" title="var">m</span> &lt; <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Search</span> (<span class="id" title="var">_</span> &lt; <span class="id" title="var">S</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
Подходящая теорема:
<span class="inlinecode"><span class="id" title="var">lt_n_Sm_le</span>:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">lt_n_Sm_le</span>.<br/>
</div>

<div class="doc">
Печатается теорема выше. 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<span class="id" title="var">lt_n_Sm_le</span> <span class="id" title="var">m</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">m0</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">m0</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m0</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<span class="id" title="var">lt_n_Sm_le</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<span class="id" title="var">lt_n_Sm_le</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>).<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 
</div>
<div class="code">
<span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> := <span class="id" title="var">lt_n_Sm_le</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>).<br/>
</div>

<div class="doc">
Появилась посылка <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">n</span></span> 
<div class="paragraph"> </div>

 Вместо последней тактики можно использовать следующую комбинацию
<span class="inlinecode"><span class="id" title="tactic">assert</span></span> и <span class="inlinecode"><span class="id" title="tactic">specialize</span></span>.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> := <span class="id" title="var">lt_n_Sm_le</span>).<br/>
<span class="id" title="tactic">specialize</span> (<span class="id" title="var">H1</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H</span>).
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> (<span class="id" title="var">_</span> ≤ <span class="id" title="var">_</span> → <span class="id" title="var">_</span> ∨ <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
Подходящая теорема :
<span class="inlinecode"><span class="id" title="var">le_lt_or_eq</span>:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span>,</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">m</span></span> 
</div>
<div class="code">
<span class="id" title="keyword">Check</span> (<span class="id" title="var">le_lt_or_eq</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H1</span>).<br/>
</div>

<div class="doc">
m &lt; n \/ m = n 
</div>
<div class="code">
<span class="id" title="tactic">assert</span> (<span class="id" title="var">H2</span> := <span class="id" title="var">le_lt_or_eq</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">H1</span>).<br/>
<span class="id" title="tactic">apply</span> <span class="id" title="var">or_comm</span>. <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a id="lab12"></a><h2 class="section">Домашнее задание</h2>


<div class="paragraph"> </div>

1. Докажите выводимость следующих суждений в лямбда-исчислении с
простыми типами.

<div class="paragraph"> </div>

Оператор, переставляющий аргументы у функции

<div class="paragraph"> </div>

<span class="inlinecode">|-</span> <span class="inlinecode"><span class="id" title="var">λf</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>.</span> <span class="inlinecode"><span class="id" title="var">λy</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>.</span> <span class="inlinecode"><span class="id" title="var">λx</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>.</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">:</span>
   <span class="inlinecode">(<span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<span class="id" title="var">B</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">C</span>)</span>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">|- <span class="id" title="var">λf</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>. <span class="id" title="var">λg</span> : <span class="id" title="var">A</span> → <span class="id" title="var">B</span>. <span class="id" title="var">λx</span> : <span class="id" title="var">A</span>. (<span class="id" title="var">f</span> <span class="id" title="var">x</span>) (<span class="id" title="var">g</span> <span class="id" title="var">x</span>) :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">A</span> → <span class="id" title="var">B</span> → <span class="id" title="var">C</span>) → (<span class="id" title="var">A</span> → <span class="id" title="var">B</span>) → (<span class="id" title="var">A</span> → <span class="id" title="var">C</span>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">Exercise</span>.<br/>

<br/>
</div>

<div class="doc">
2. Рассмотрим следующее недоказуемое утверждение. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">H</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, 0 &lt; <span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">
С помощью <span class="inlinecode"><span class="id" title="var">H</span></span> напишите правые части следующих определений,
используя лямбда-абстракцию, аппликацию и зависимые типы. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">t1</span></span> <span class="inlinecode">:</span> <span class="inlinecode">0</span> <span class="inlinecode">&lt;</span> <span class="inlinecode">1</span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">t2</span></span> <span class="inlinecode">:</span> <span class="inlinecode">0</span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">t3</span></span> <span class="inlinecode">:</span> <span class="inlinecode">2</span> <span class="inlinecode">*</span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">5</span> <span class="inlinecode">→</span> <span class="inlinecode">0</span> <span class="inlinecode">&lt;</span> <span class="inlinecode">0</span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>

<div class="paragraph"> </div>

 Найдите подходящие теоремы из библиотеки для использования в
следующих определениях. 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">t5</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">False</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>

<div class="paragraph"> </div>

<span class="inlinecode"><span class="id" title="keyword">Definition</span></span> <span class="inlinecode"><span class="id" title="var">t6</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> <span class="inlinecode">:=</span> <span class="inlinecode">...</span>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Exercise</span>.<br/>

<br/>
</div>

<div class="doc">
3. Суммой <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B2</span></span>, или дизъюнктным объединением, множеств <span class="inlinecode"><span class="id" title="var">B1</span></span> и <span class="inlinecode"><span class="id" title="var">B2</span></span>, называется
объединении непересекающихся «копий» этих множеств. Например, <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B2</span></span>
можно реализовать как <span class="inlinecode">{(1,</span> <span class="inlinecode"><span class="id" title="var">x</span>)</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">B1</span>}</span> <span class="inlinecode">∪</span> <span class="inlinecode">{(2,</span> <span class="inlinecode"><span class="id" title="var">y</span>)</span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">B2</span>}</span>. Эту операцию
обобщается на произвольное семейство множеств <span class="inlinecode">{<span class="id" title="var">Bi</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">A</span>}</span>. Что является
аналогом операции зависимой суммы со стороны логики? 
<div class="paragraph"> </div>

<a id="lab13"></a><h3 class="section">Дальнейшая информация о бестиповом и типовом лямбда-исчислении</h3>


<div class="paragraph"> </div>

Лекции по функциональному программированию.
Разделы 2, 3 до 3.6 и 6 до 6.1 включительно
(см. <a href="https://source.unn.ru">source.unn.ru</a>).

<div class="paragraph"> </div>

Пирс Б. Типы в языках программирования. 2011.
Разделы 5.1, 9.1-9.2.
<a href="http://newstar.rinet.ru/~goga/tapl">http://newstar.rinet.ru/~goga/tapl</a>.

<div class="paragraph"> </div>

Крупский В.Н., Кузнецов С.Л. Компьютерный практикум по математической логике: Coq.
Разделы 1.1-1.2.
<a href="http://www.mi.ras.ru/~sk/lehre/coq">http://www.mi.ras.ru/~sk/lehre/coq</a>. 
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>