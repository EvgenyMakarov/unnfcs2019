<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>projects1</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">
</div>

<div class="doc">
<a id="lab1"></a><h1 class="section">Проекты для группы 3822М1ПМкн</h1>


<div class="paragraph"> </div>

Для получения зачета нужно выполнить проект и знать содержание лекций,
в частности, информацию про теорию зависимых типов. Сдача проектов
будет происходить до или одновременно со сдачей других зачетов.

<div class="paragraph"> </div>

Почти в каждом проекте нужно написать рекурсивную функцию и ее
спецификацию, а затем доказать, что написанная функция удовлетворяет
спецификации. Пример: нахождение максимума массива в лекции 6.

<div class="paragraph"> </div>

Проекты выполняются индивидуально или парами. Нужно выбрать одну из
тем, приведенных ниже, и записать свой выбор в <a
href="https://forms.gle/5QHwqEjUFaJK2MRA8">этой форме</a>. Над
каждой темой может работать не более одной команды.
Темы распределяются в порядке поступления заявок. Прежде заполнения
формы следует посмотреть в <a
href="https://docs.google.com/spreadsheets/d/1B8DaEQ3wNvDgOYb45gI5KBgIU76h56o0g1b1E4MKA3M/edit?usp=sharing">таблицу</a>,
в которой записываются поданные заявки, и выбрать тему, которая еще не
задана. Если будет подано более одной заявки с одной и той же темой,
то приоритет будет за первой командой.

<div class="paragraph"> </div>

После того, как вы напишете функцию и спецификацию и до начала
доказательства пришлите спецификацию преподавателю для проверки на
портале или по электронной почте <code>emakarov@gmail.com</code>
(в теме письма укажите <code><span class="inlinecode">[СПКН2023]</span></code> с квадратными
скобками). Также присылайте все возникающие вопросы.

<div class="paragraph"> </div>

Главное правило при выполнении проекта заключается в следующем: у вас
должно быть очень подробное доказательства требуемых утверждений на
бумаге, прежде чем вы начнете реализовывать их на компьютере. В каждый
момент доказательства на компьютере вы должны понимать, в каком месте
бумажного доказательства вы находитесь и почему Coq предлагает вам
доказать именно эти цели. Вы, а не компьютер, должны определять
направление, в котором идет доказательство. Если вы начнете случайным
образом подбирать тактики, надеясь, что это приведет к нужному
результату, вы вряд ли добьетесь успеха.

<div class="paragraph"> </div>

Вспомогательные факты следует оформить как леммы. Например, так можно
поступить с шагом индукции, чтобы основное доказательство было
компактным.

<div class="paragraph"> </div>

Не забывайте скопировать инструкции <span class="inlinecode"><span class="id" title="var">import</span></span> и определение тактики
<span class="inlinecode"><span class="id" title="var">bdestruct</span></span>, которые находятся в начале лекции 7.

<div class="paragraph"> </div>

В начале файла напишите номер и краткое описание проекта (одно-два
предложения). Следует писать подробные комментарии. В частности, перед
каждой функцией нужно написать, что она принимает и возвращает.
Простые спецификации комментировать необязательно, но если в
реализации функций или в формулах есть что-то неочевидное, это нужно
описать.

<div class="paragraph"> </div>

<a id="lab2"></a><h2 class="section">Описание проектов</h2>


<div class="paragraph"> </div>

<strong>1.</strong> Определить для данных <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> и <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
является ли ограничение <span class="inlinecode"><span class="id" title="var">f</span></span> на <span class="inlinecode">{0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">n</span>}</span> инъекцией.

<div class="paragraph"> </div>

<strong>2.</strong> Определить для данных <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> и
<span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, имеет ли место <span class="inlinecode">{0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">n</span>}</span> <span class="inlinecode">⊆</span> <span class="inlinecode">{<span class="id" title="var">f</span></span> <span class="inlinecode">0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">m</span>}</span>.
Таким образом, если <span class="inlinecode"><span class="id" title="var">f</span></span> отображает <span class="inlinecode">{0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">m</span>}</span> в <span class="inlinecode">{0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">n</span>}</span>,
нужно определить, является ли <span class="inlinecode"><span class="id" title="var">f</span></span> сюръекцией.

<div class="paragraph"> </div>

<strong>3.</strong> Определить, встречается ли число в двумерном
массиве. Массив моделируется функцией типа <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
количеством строк и количеством столбцов.

<div class="paragraph"> </div>

Сначала задачу нужно решить для одномерного массива. Для этого нужно
дать следующее определение:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">search1</span> (<span class="id" title="var">n</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> := ...
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

и доказать

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Theorem</span> <span class="id" title="var">search1Spec</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>, (<span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> &lt; <span class="id" title="var">n</span> ∧ <span class="id" title="var">array</span> <span class="id" title="var">i</span> = <span class="id" title="var">x</span>) ↔ <span class="id" title="var">search1</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Эти определения и доказательства нужно поместить в раздел. Как описано
в лекции 7, после закрытия этого раздела функция <span class="inlinecode"><span class="id" title="var">search1</span></span> будет
принимать дополнительный аргумент <span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, а спецификация
<span class="inlinecode"><span class="id" title="var">search1Spec</span></span> будет начинаться с <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode">(<span class="id" title="var">array</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span>)</span>.

<div class="paragraph"> </div>

В следующем разделе нужно написать функцию

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">search2</span> (<span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">bool</span> := ...
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

и доказать

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Theorem</span> <span class="id" title="var">search2Spec</span>: <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span>, <span class="id" title="var">j</span> &lt; <span class="id" title="var">m</span> ∧ <span class="id" title="var">k</span> &lt; <span class="id" title="var">n</span> ∧ <span class="id" title="var">array2</span> <span class="id" title="var">j</span> <span class="id" title="var">k</span> = <span class="id" title="var">x</span>) ↔<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">search2</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">x</span> = <span class="id" title="var">true</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

В определении <span class="inlinecode"><span class="id" title="var">search2</span></span> нужно использовать <span class="inlinecode"><span class="id" title="var">search1</span></span>, потому что если
<span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, то для каждого <span class="inlinecode"><span class="id" title="var">j</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> выражение <span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode"><span class="id" title="var">j</span></span>
имеет тип <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>. Аналогично в доказательстве <span class="inlinecode"><span class="id" title="var">search2Spec</span></span> следует
использовать <span class="inlinecode"><span class="id" title="var">search1Spec</span></span>.

<div class="paragraph"> </div>

<strong>4.</strong> Найти максимум двумерного массива. Массив
моделируется, как в предыдущей задаче. Как и там, задачу сначала нужно
решить для одномерного массива и затем использовать этот результат.

<div class="paragraph"> </div>

<strong>5.</strong> Проверить, является ли массив <span class="inlinecode"><span class="id" title="var">a</span></span> палиндромом,
то есть имеет ли место <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode"><span class="id" title="var">j</span>,</span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">j</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">j</span></span>.

<div class="paragraph"> </div>

Предлагается написать вспомогательную функцию <span class="inlinecode"><span class="id" title="var">isPalindromeHelp</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">bool</span></span>,
такую что, например,

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">isPalindromeHelp</span> 0 3<br/>
= <span class="id" title="var">a</span> 0 =? <span class="id" title="var">a</span> 3 &amp;&amp; <span class="id" title="var">isPalindromeHelp</span> 1 2<br/>
= <span class="id" title="var">a</span> 0 =? <span class="id" title="var">a</span> 3 &amp;&amp; <span class="id" title="var">a</span> 1 =? <span class="id" title="var">a</span> 2 &amp;&amp; <span class="id" title="var">isPalindromeHelp</span> 2 1<br/>
= <span class="id" title="var">a</span> 0 =? <span class="id" title="var">a</span> 3 &amp;&amp; <span class="id" title="var">a</span> 1 =? <span class="id" title="var">a</span> 2 &amp;&amp; <span class="id" title="var">a</span> 2 =? <span class="id" title="var">a</span> 1 &amp;&amp; <span class="id" title="var">isPalindromeHelp</span> 3 0<br/>
= <span class="id" title="var">a</span> 0 =? <span class="id" title="var">a</span> 3 &amp;&amp; <span class="id" title="var">a</span> 1 =? <span class="id" title="var">a</span> 2 &amp;&amp; <span class="id" title="var">a</span> 2 =? <span class="id" title="var">a</span> 1 &amp;&amp; <span class="id" title="var">a</span> 3 =? <span class="id" title="var">a</span> 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

В этом проекте не следует использовать усеченную разность на натуральных
числах, обозначенную обычным минусом в стандартной библиотеке.

<div class="paragraph"> </div>

<strong>6.</strong> Проверить, является ли список палиндромом.

<div class="paragraph"> </div>

<strong>7.</strong> Найти наибольший общий делитель чисел <span class="inlinecode"><span class="id" title="var">m</span></span> и <span class="inlinecode"><span class="id" title="var">n</span></span> c помощью алгоритма Евклида. Необходимо использовать сильную (возвратную) индукцию, как описано в лекции 8.

<div class="paragraph"> </div>

<strong>8.</strong> Найти наибольший общий делитель чисел <span class="inlinecode"><span class="id" title="var">m</span></span> и <span class="inlinecode"><span class="id" title="var">n</span></span>, перебирая числа от <span class="inlinecode"><span class="id" title="var">min</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> до <span class="inlinecode">1</span>.

<div class="paragraph"> </div>

В Coq есть операция <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> (или <span class="inlinecode"><span class="id" title="var">modulo</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>), которая возвращает
остаток от деления <span class="inlinecode"><span class="id" title="var">m</span></span> на <span class="inlinecode"><span class="id" title="var">n</span></span>. Однако поскольку все функции в Coq
являются тотальными, значение выражения <span class="inlinecode"><span class="id" title="var">m</span></span> <span class="inlinecode"><span class="id" title="var">mod</span></span> <span class="inlinecode">0</span> равно <span class="inlinecode">0</span> по
определению. Также есть предикат <span class="inlinecode">(<span class="id" title="var">n</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">m</span>)</span> (пишется в скобках; или
<span class="inlinecode"><span class="id" title="var">divide</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span>), который равен <span class="inlinecode"><span class="id" title="var">True</span></span>, если <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">делит</span> <span class="inlinecode"><span class="id" title="var">m</span></span>. Следует
обратить внимание, что <span class="inlinecode"><span class="id" title="var">modulo</span></span> возвращает <span class="inlinecode"><span class="id" title="var">nat</span></span> и следовательно может
быть использован в программах, в то время как <span class="inlinecode"><span class="id" title="var">divide</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode"><span class="id" title="var">m</span></span> возвращает
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span> и может использоваться только в спецификациях.

<div class="paragraph"> </div>

<strong>9.</strong> Проверить, является ли число <span class="inlinecode"><span class="id" title="var">n</span></span> простым с помощью перебора всех
потенциальных делителей от <span class="inlinecode">2</span> до <span class="inlinecode"><span class="id" title="var">n</span>-1</span>. При желании можно перебирать числа
до квадратного корня из <span class="inlinecode"><span class="id" title="var">n</span></span>.

<div class="paragraph"> </div>

<strong>10.</strong> Найти целочисленный корень уравнения <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span>
<span class="inlinecode"><span class="id" title="var">y</span></span>. Рассмотрим следующие предположения (должны быть объявлены внутри
<span class="inlinecode"><span class="id" title="keyword">Section</span></span>).

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Variables</span> <span class="id" title="var">f</span> <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">y</span> : <span class="id" title="var">nat</span>.<br/>
<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">f_unbounded</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> &lt; <span class="id" title="var">f</span> (<span class="id" title="var">g</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">f0</span> : <span class="id" title="var">f</span> 0 ≤ <span class="id" title="var">y</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Гипотеза <span class="inlinecode"><span class="id" title="var">f_unbounded</span></span> говорит, что <span class="inlinecode"><span class="id" title="var">f</span></span> неограниченна, а функция <span class="inlinecode"><span class="id" title="var">g</span></span>
при этом выступает в качестве свидетеля. Целочисленным корнем
уравнения <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">y</span></span> называется такой <span class="inlinecode"><span class="id" title="var">x</span></span>, что <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">y</span></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">x</span>+1)</span>
(здесь двойное неравенство есть сокращение для конъюнкции неравенств;
такая запись возможна и в Coq). Нужно написать функцию, которая в
предположениях неограниченности <span class="inlinecode"><span class="id" title="var">f</span></span> и <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">0</span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">y</span></span> находит целочисленный
корень. Функция может перебирать значения <span class="inlinecode"><span class="id" title="var">x</span></span>, начиная с числа,
предшествующего <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">y</span>)</span>, до 0 и проверять, являются ли они корнями
уравнения. Проверьте работу функции при <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span>×<span class="id" title="var">x</span></span> и <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">n</span>+1</span>.

<div class="paragraph"> </div>

<strong>11.</strong> Рассмотрим представление натуральных чисел по
основанию <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">&gt;</span> <span class="inlinecode">1</span>. Цифры числа содержатся в массиве типа <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>,
причем самый младший разряд имеет индекс 0. Нужно написать
следующие функции.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">carry</span> (<span class="id" title="var">a1</span> <span class="id" title="var">a2</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := ...
<div class="paragraph"> </div>

</span>Возвращает перенос с n-го на (n+1)-й разряд при сложении чисел,
представленных массивами <span class="inlinecode"><span class="id" title="var">a1</span></span> и <span class="inlinecode"><span class="id" title="var">a2</span></span>.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Definition</span> <span class="id" title="var">add</span> (<span class="id" title="var">a1</span> <span class="id" title="var">a2</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := ...
<div class="paragraph"> </div>

</span>Возвращает n-ую цифру суммы чисел, представленных массивами <span class="inlinecode"><span class="id" title="var">a1</span></span> и
<span class="inlinecode"><span class="id" title="var">a2</span></span> (n ≥ 0).

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">toNat</span> (<span class="id" title="var">a</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>) (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := ...
<div class="paragraph"> </div>

</span>Возвращает число, представленное массивом <span class="inlinecode"><span class="id" title="var">a</span></span>.

<div class="paragraph"> </div>

Также требуется доказать, что функции <span class="inlinecode"><span class="id" title="var">carry</span></span> и <span class="inlinecode"><span class="id" title="var">add</span></span> определены
корректно, то есть число, представленное массивом <span class="inlinecode"><span class="id" title="var">add</span></span> <span class="inlinecode"><span class="id" title="var">a1</span></span> <span class="inlinecode"><span class="id" title="var">a2</span></span>,
является суммой чисел, представленных <span class="inlinecode"><span class="id" title="var">a1</span></span> и <span class="inlinecode"><span class="id" title="var">a2</span></span>.

<div class="paragraph"> </div>

<strong>12.</strong> Данный проект аналогичен предыдущему, но цифры
двух чисел хранятся в двух списках. Функция <span class="inlinecode"><span class="id" title="var">add</span></span> также возвращает список.

<div class="paragraph"> </div>

<strong>13.</strong> Вычислить значение полинома в точке <span class="inlinecode"><span class="id" title="var">x</span></span> методом
Горнера и доказать, что оно равно значению, вычисленному обычным
образом. Для данного <span class="inlinecode"><span class="id" title="var">n</span></span> массив a представляет полином <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode">0)*<span class="id" title="var">x</span>^<span class="id" title="var">n</span></span> <span class="inlinecode">+</span> <span class="inlinecode">(<span class="id" title="var">a</span></span>
<span class="inlinecode">1)*<span class="id" title="var">x</span>^(<span class="id" title="var">n</span>-1)</span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Про метод Горнера см. упражнение 3 в домашнем
задании 6 из прошлого семестра. Под вычислением обычным образом
имеется в виду функция, также определенная рекурсией по <span class="inlinecode"><span class="id" title="var">n</span></span>, но которая
вычисляет <span class="inlinecode">(<span class="id" title="var">a</span></span> <span class="inlinecode"><span class="id" title="var">i</span>)*<span class="id" title="var">x</span>^<span class="id" title="var">i</span></span> для каждого монома и возвращает сумму результатов.

<div class="paragraph"> </div>

<strong>14.</strong> Данный проект аналогичен предыдущему, но коэффициенты
многочлена хранятся в списке. Младший коэффициент находится в голове списка.

<div class="paragraph"> </div>

<strong>15.</strong> Реализовать быстрое умножение двоичного числа
на число Пеано. Двоичное число представлено массивом из <span class="inlinecode">0</span> и <span class="inlinecode">1</span> длины
<span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Старшие биты числа, как обычно, находятся слева. Второе число —
это просто элемент типа <span class="inlinecode"><span class="id" title="var">nat</span></span>. Требуется реализовать метод умножения,
описанный в прошлом семестре.
Также нужно написать функцию <span class="inlinecode"><span class="id" title="var">binToNat</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="var">nat</span></span>, такую что <span class="inlinecode"><span class="id" title="var">binToNat</span></span>
<span class="inlinecode"><span class="id" title="var">n</span></span> возвращает число, представляемое массивом длины <span class="inlinecode"><span class="id" title="var">n</span>+1</span>. Спецификация
алгоритма, которую требуется доказать, говорит

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">y</span>, <span class="id" title="var">fastMult</span> <span class="id" title="var">n</span> <span class="id" title="var">y</span> = (<span class="id" title="var">binToNat</span> <span class="id" title="var">n</span>) × <span class="id" title="var">y</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Можно написать гипотезу (<span class="inlinecode"><span class="id" title="keyword">Hypothesis</span></span>, внутри <span class="inlinecode"><span class="id" title="keyword">Section</span></span>), говорящую, что
массив содержит только нули и единицы.

<div class="paragraph"> </div>

<strong>16.</strong> Данный проект аналогичен предыдущему, но цифры
первого числа хранятся в списке (младший бит находится в голове
списка).

<div class="paragraph"> </div>

<strong>17.</strong> Даны следующие функции и предположения.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Variables</span> <span class="id" title="var">f</span>, <span class="id" title="var">g</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>
<br/>
<span class="id" title="keyword">Hypothesis</span> <span class="id" title="var">g_not_surj</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">g</span> <span class="id" title="var">n</span> ≠ 0
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Таким образом, <span class="inlinecode"><span class="id" title="var">g</span></span> не является сюръекцией. Нужно доказать, что
композиция <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">g</span></span> <span class="inlinecode"><span class="id" title="var">o</span></span> <span class="inlinecode"><span class="id" title="var">f</span></span> не является тождественной функцией, то есть
найдется <span class="inlinecode"><span class="id" title="var">n</span></span>, такой что <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Существует конструктивное и
неконструктивное доказательства этого факта. Нужно написать
конструктивное доказательство, то есть написать алгоритм, который
находит <span class="inlinecode"><span class="id" title="var">n</span></span>, и доказать, что <span class="inlinecode"><span class="id" title="var">f</span></span> <span class="inlinecode">(<span class="id" title="var">g</span></span> <span class="inlinecode">(<span class="id" title="var">f</span></span> <span class="inlinecode"><span class="id" title="var">n</span>))</span> <span class="inlinecode">≠</span> <span class="inlinecode"><span class="id" title="var">n</span></span>. Полученный алгоритм
достаточно прост, но найти его может быть не совсем тривиальной
задачей.

<div class="paragraph"> </div>

Если у вас есть другая идея для проекта, вы можете обсудить ее с
преподавателем. 
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>