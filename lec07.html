<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>maximum</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab1"></a><h1 class="section">Верификация поиска максимума в массиве</h1>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Arith</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Lia</span>.<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Bool</span>.<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Nat</span> <span class="id" title="var">Peano</span>.<br/>

<br/>
<span class="id" title="keyword">Hint Resolve</span> <span class="id" title="var">ltb_spec0</span> <span class="id" title="var">leb_spec0</span> <span class="id" title="var">eqb_spec</span> : <span class="id" title="var">bdestruct</span>.<br/>

<br/>
<span class="id" title="keyword">Ltac</span> <span class="id" title="var">bdestr</span> <span class="id" title="var">X</span> <span class="id" title="var">H</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">let</span> <span class="id" title="var">e</span> := <span class="id" title="tactic">fresh</span> "e" <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">evar</span> (<span class="id" title="var">e</span> : <span class="id" title="keyword">Prop</span>);<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">H</span> : <span class="id" title="var">reflect</span> <span class="id" title="var">e</span> <span class="id" title="var">X</span>); <span class="id" title="tactic">subst</span> <span class="id" title="var">e</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[ <span class="id" title="tactic">eauto</span> <span class="id" title="keyword">with</span> <span class="id" title="var">bdestruct</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[ | <span class="id" title="tactic">try</span> <span class="id" title="tactic">first</span> [<span class="id" title="tactic">apply</span> <span class="id" title="var">nlt_ge</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span> | <span class="id" title="tactic">apply</span> <span class="id" title="var">nle_gt</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>]]].<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "bdestruct" <span class="id" title="keyword">constr</span>(<span class="id" title="var">X</span>) := <span class="id" title="keyword">let</span> <span class="id" title="var">H</span> := <span class="id" title="tactic">fresh</span> <span class="id" title="tactic">in</span> <span class="id" title="var">bdestr</span> <span class="id" title="var">X</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Tactic Notation</span> "bdestruct" <span class="id" title="keyword">constr</span>(<span class="id" title="var">X</span>) "as" <span class="id" title="var">ident</span>(<span class="id" title="var">H</span>) := <span class="id" title="var">bdestr</span> <span class="id" title="var">X</span> <span class="id" title="var">H</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">ArrayMax</span>.<br/>

<br/>
</div>

<div class="doc">
Функция <span class="inlinecode"><span class="id" title="var">array</span></span> ниже моделирует массив. <span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode"><span class="id" title="var">i</span></span> есть <span class="inlinecode"><span class="id" title="var">i</span></span>-й
элемент. Подразумевается, что индексы не превосходят некоторый
параметр <span class="inlinecode"><span class="id" title="var">n</span></span>. Таким образом, <span class="inlinecode"><span class="id" title="var">n</span></span> есть длина массива + 1. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">array</span> : <span class="id" title="var">nat</span> → <span class="id" title="var">nat</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" title="var">arrayMax</span></span> <span class="inlinecode"><span class="id" title="var">n</span></span> возвращает <span class="inlinecode"><span class="id" title="var">max</span>(<span class="id" title="var">array</span></span> <span class="inlinecode">0,</span> <span class="inlinecode">...,</span> <span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span>. Массив
непустой для любого n &gt;= 0, поэтому максимум определен. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">arrayMax</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| 0 ⇒ <span class="id" title="var">array</span> 0<br/>
| <span class="id" title="var">S</span> <span class="id" title="var">k</span> ⇒ <span class="id" title="var">max</span> (<span class="id" title="var">arrayMax</span> <span class="id" title="var">k</span>) (<span class="id" title="var">array</span> <span class="id" title="var">n</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
Идентификаторы <span class="inlinecode"><span class="id" title="var">Init.Nat.max</span></span> и т.п., появляющиеся в доказательстве,
обозначают то же, что и <span class="inlinecode"><span class="id" title="var">max</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">arrayMaxSpec1</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> → <span class="id" title="var">array</span> <span class="id" title="var">i</span> ≤ <span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>]; <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">H</span>.<br/>
* <span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> : <span class="id" title="var">i</span> = 0) <span class="id" title="tactic">by</span> <span class="id" title="var">lia</span>. <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H1</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
</div>

<div class="doc">
Тактика <span class="inlinecode"><span class="id" title="tactic">reflexivity</span></span> доказывает не только <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">M</span></span>,
   но и <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">≤</span> <span class="inlinecode"><span class="id" title="var">M</span></span>. 
</div>
<div class="code">
* <span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> : <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∨ <span class="id" title="var">i</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">lia</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
Эта посылка больше не нужна. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
</div>

<div class="doc">
Упрощение <span class="inlinecode"><span class="id" title="var">arrayMax</span></span> <span class="inlinecode">(<span class="id" title="var">S</span></span> <span class="inlinecode"><span class="id" title="var">n</span>)</span> по определению. 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H1</span> | <span class="id" title="var">H1</span>].<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> (<span class="id" title="var">le_trans</span> <span class="id" title="var">_</span> (<span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">auto</span>.<br/>
</div>

<div class="doc">
Следует непосредственно из предположения индукции. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">apply</span> <span class="id" title="var">le_max_l</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">subst</span> <span class="id" title="var">i</span>.<br/>
</div>

<div class="doc">
Или <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H1</span></span>. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">apply</span> <span class="id" title="var">le_max_r</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Тактика <span class="inlinecode"><span class="id" title="tactic">subst</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> ищет посылку вида <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">M</span></span> или <span class="inlinecode"><span class="id" title="var">M</span></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">x</span></span> и заменяет
<span class="inlinecode"><span class="id" title="var">x</span></span> на <span class="inlinecode"><span class="id" title="var">M</span></span> во всей цели. 
<div class="paragraph"> </div>

 Функция <span class="inlinecode"><span class="id" title="var">arrayMax</span></span> вместо конструкции <span class="inlinecode"><span class="id" title="keyword">if</span></span> использует <span class="inlinecode"><span class="id" title="var">max</span></span>, и
доказательство использует свойства <span class="inlinecode"><span class="id" title="var">max</span></span> из библиотеки. Определим
аналогичную функцию с помощью <span class="inlinecode"><span class="id" title="keyword">if</span></span> и используем рефлексию в
доказательстве. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">arrayMax'</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| 0 ⇒ <span class="id" title="var">array</span> 0<br/>
| <span class="id" title="var">S</span> <span class="id" title="var">k</span> ⇒ <span class="id" title="keyword">let</span> <span class="id" title="var">p</span> := <span class="id" title="var">arrayMax'</span> <span class="id" title="var">k</span> <span class="id" title="tactic">in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">if</span> <span class="id" title="var">p</span> &lt;=? <span class="id" title="var">array</span> <span class="id" title="var">n</span> <span class="id" title="keyword">then</span> <span class="id" title="var">array</span> <span class="id" title="var">n</span> <span class="id" title="keyword">else</span> <span class="id" title="var">p</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">arrayMaxSpec1'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> → <span class="id" title="var">array</span> <span class="id" title="var">i</span> ≤ <span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>]; <span class="id" title="tactic">intros</span> <span class="id" title="var">i</span> <span class="id" title="var">H</span>.<br/>
* <span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> : <span class="id" title="var">i</span> = 0) <span class="id" title="tactic">by</span> <span class="id" title="var">lia</span>. <span class="id" title="var">now</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H1</span>.<br/>
* <span class="id" title="tactic">assert</span> (<span class="id" title="var">H1</span> : <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∨ <span class="id" title="var">i</span> = <span class="id" title="var">S</span> <span class="id" title="var">n</span>) <span class="id" title="tactic">by</span> <span class="id" title="var">lia</span>; <span class="id" title="tactic">clear</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">destruct</span> <span class="id" title="var">H1</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">H1</span> | <span class="id" title="var">H1</span>].<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">apply</span> (<span class="id" title="var">le_trans</span> <span class="id" title="var">_</span> (<span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">bdestruct</span> (<span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span> &lt;=? <span class="id" title="var">array</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="tactic">assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-- <span class="id" title="tactic">reflexivity</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">subst</span> <span class="id" title="var">i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">bdestruct</span> (<span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span> &lt;=? <span class="id" title="var">array</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">easy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;- <span class="id" title="var">now</span> <span class="id" title="tactic">apply</span> <span class="id" title="var">lt_le_incl</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Докажем вторую часть спецификации, которая говорит, что
<span class="inlinecode"><span class="id" title="var">arrayMax</span></span> берет результат из массива. 
<div class="paragraph"> </div>

 Нам понадобится лемма. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">max_variants</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>, <span class="id" title="var">max</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> = <span class="id" title="var">m</span> ∨ <span class="id" title="var">max</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> = <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">intros</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">max_spec</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>) <span class="id" title="keyword">as</span> [[<span class="id" title="var">_</span> <span class="id" title="var">H</span>] | [<span class="id" title="var">_</span> <span class="id" title="var">H</span>]]; [<span class="id" title="tactic">right</span> | <span class="id" title="tactic">left</span>]; <span class="id" title="tactic">assumption</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">arrayMaxSpec2</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∧ <span class="id" title="var">array</span> <span class="id" title="var">i</span> = <span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>].<br/>
* <span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
* <span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">i</span> [<span class="id" title="var">IH1</span> <span class="id" title="var">IH2</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">arrayMax</span>. <span class="id" title="tactic">destruct</span> (<span class="id" title="var">max_variants</span> (<span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>) (<span class="id" title="var">array</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>].<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">split</span>; [<span class="id" title="tactic">auto</span> |].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">congruence</span>.<br/>
</div>

<div class="doc">
Тактика <span class="inlinecode"><span class="id" title="tactic">congruence</span></span> доказывает равенство из других равенств.
        Альтернативно: rewrite H; assumption. 
</div>
<div class="code">
&nbsp;&nbsp;+ <span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>). <span class="id" title="tactic">rewrite</span> <span class="id" title="var">H</span>. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Версия, использующая <span class="inlinecode"><span class="id" title="var">arrayMax'</span></span> вместо <span class="inlinecode"><span class="id" title="var">arrayMax</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">arrayMaxSpec2'</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∧ <span class="id" title="var">array</span> <span class="id" title="var">i</span> = <span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>].<br/>
* <span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
* <span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">i</span> [<span class="id" title="var">IH1</span> <span class="id" title="var">IH2</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">arrayMax'</span>. <span class="id" title="var">bdestruct</span> (<span class="id" title="var">arrayMax'</span> <span class="id" title="var">n</span> &lt;=? <span class="id" title="var">array</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)) <span class="id" title="keyword">as</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>). <span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
&nbsp;&nbsp;+ <span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">auto</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Еще одна реализация <span class="inlinecode"><span class="id" title="var">arrayMax</span></span>, на этот раз с хвостовой рекурсией. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">arrayMaxHelp</span> (<span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| 0 ⇒ <span class="id" title="var">max</span> (<span class="id" title="var">array</span> 0) <span class="id" title="var">m</span><br/>
| <span class="id" title="var">S</span> <span class="id" title="var">k</span> ⇒ <span class="id" title="var">arrayMaxHelp</span> <span class="id" title="var">k</span> (<span class="id" title="var">max</span> (<span class="id" title="var">array</span> <span class="id" title="var">n</span>) <span class="id" title="var">m</span>)<br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">arrayMaxTail</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> := <span class="id" title="var">arrayMaxHelp</span> <span class="id" title="var">n</span> (<span class="id" title="var">array</span> <span class="id" title="var">n</span>).<br/>

<br/>
</div>

<div class="doc">
Докажем равенство <span class="inlinecode"><span class="id" title="var">arrayMax</span></span> и <span class="inlinecode"><span class="id" title="var">arrayMaxTail</span></span>. Сначала докажем
более общее утверждение про <span class="inlinecode"><span class="id" title="var">arrayMax</span></span> и <span class="inlinecode"><span class="id" title="var">arrayMaxHelp</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">maxHelpEqual</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">max</span> (<span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>) <span class="id" title="var">m</span> = <span class="id" title="var">arrayMaxHelp</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>]; <span class="id" title="tactic">intro</span> <span class="id" title="var">m</span>; [<span class="id" title="tactic">reflexivity</span> |].<br/>
<span class="id" title="tactic">simpl</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">IH</span>, <span class="id" title="var">max_assoc</span>. <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">maxEqual</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span> = <span class="id" title="var">arrayMaxTail</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">intro</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">unfold</span> <span class="id" title="var">arrayMaxTail</span>. <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">maxHelpEqual</span>.<br/>
<span class="id" title="tactic">destruct</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span>]; <span class="id" title="tactic">simpl</span>.<br/>
* <span class="id" title="tactic">rewrite</span> <span class="id" title="var">max_id</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
* <span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">max_assoc</span>, <span class="id" title="var">max_id</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab2"></a><h2 class="section">Конструктивная версия <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2</span></span></h2>


<div class="paragraph"> </div>

См. упражнение 3 в конце лекции 5.

<div class="paragraph"> </div>

Если <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">=</span> <span class="inlinecode">{1,</span> <span class="inlinecode">2,</span> <span class="inlinecode">...}</span>, а <span class="inlinecode"><span class="id" title="var">Bi</span></span> — множество для каждого <span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">A</span></span>, то
элементами зависимой суммы <span class="inlinecode"><span class="id" title="var">B1</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">B2</span></span> <span class="inlinecode">+</span> <span class="inlinecode">...</span> являются пары <span class="inlinecode">(<span class="id" title="var">i</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>, где
<span class="inlinecode"><span class="id" title="var">i</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">A</span></span> и <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">∈</span> <span class="inlinecode"><span class="id" title="var">Bi</span></span>. В теории типов аналогом зависимой суммы множеств
является тип <span class="inlinecode">∃<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>, где <span class="inlinecode"><span class="id" title="var">x</span></span> может входить свободно в <span class="inlinecode"><span class="id" title="var">B</span></span>.
Термами этого типа являются пары <span class="inlinecode">(<span class="id" title="var">a</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span>, где <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> и <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">a</span>/<span class="id" title="var">x</span>]</span>. Если
<span class="inlinecode"><span class="id" title="var">B</span></span> есть формула, зависящая от <span class="inlinecode"><span class="id" title="var">x</span></span>, то согласно соответствию Карри-Говарда
пару <span class="inlinecode">(<span class="id" title="var">a</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>)</span> можно рассматривать как доказательство <span class="inlinecode">∃<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>: <span class="inlinecode"><span class="id" title="var">a</span></span> есть
свидетель утверждения о существовании и <span class="inlinecode"><span class="id" title="var">b</span></span> есть доказательство, что
<span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">a</span>/<span class="id" title="var">x</span>]</span> действительно имеет место.

<div class="paragraph"> </div>

С учетом того, что элементами зависимого произведения <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span>
являются функции, которые <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> отображают в терм типа <span class="inlinecode"><span class="id" title="var">B</span>[<span class="id" title="var">a</span>/<span class="id" title="var">x</span>]</span> (см.
лекцию 5), термы типа <span class="inlinecode">∀<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode">∃<span class="id" title="var">y</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span>,</span> <span class="inlinecode"><span class="id" title="var">P</span></span> — это функции, которые любой
терм <span class="inlinecode"><span class="id" title="var">a</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> отображают в пару <span class="inlinecode">(<span class="id" title="var">b</span>,</span> <span class="inlinecode"><span class="id" title="var">p</span>)</span>, где <span class="inlinecode"><span class="id" title="var">b</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">B</span></span> и <span class="inlinecode"><span class="id" title="var">p</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">P</span>[<span class="id" title="var">a</span>/<span class="id" title="var">x</span>,</span> <span class="inlinecode"><span class="id" title="var">b</span>/<span class="id" title="var">y</span>]</span>.
Таким образом, 

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, <span class="id" title="tactic">∃</span> <span class="id" title="var">i</span>, <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∧ <span class="id" title="var">array</span> <span class="id" title="var">i</span> = <span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

можно рассматривать как тип функций, которые принимает максимальный
индекс массива и возвращают индекс, где находится максимум.
Доказательство <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2</span></span> этого утверждения является программой,
вычисляющей эту функцию. Ее можно запустить в Coq и вычислить значение
на любом аргументе.

<div class="paragraph"> </div>

На самом деле в Coq есть две версии квантора существования:
<span class="inlinecode"><span class="id" title="tactic">∃</span></span> <span class="inlinecode"><span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span>,</span> <span class="inlinecode"><span class="id" title="var">B</span></span> предназначен только для доказательств, а <span class="inlinecode">{<span class="id" title="var">x</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">A</span></span> <span class="inlinecode">|</span> <span class="inlinecode"><span class="id" title="var">B</span>}</span>
может использоваться для вычислений, как описано выше. Формулировка
<span class="inlinecode"><span class="id" title="var">arrayMaxSpec2</span></span> использует первую версию, поэтому, чтобы иметь
возможность запускать доказательство как программу, нужно доказать
конструктивный аналог <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2</span></span>. 
<div class="paragraph"> </div>

 Это доказательство отличается от предыдущих лишь использованием
теоремы <span class="inlinecode"><span class="id" title="var">max_dec</span></span>, аналогичной лемме <span class="inlinecode"><span class="id" title="var">max_variants</span></span> выше. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">arrayMaxSpec2_constr</span> :<br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">n</span>, {<span class="id" title="var">i</span> | <span class="id" title="var">i</span> ≤ <span class="id" title="var">n</span> ∧ <span class="id" title="var">array</span> <span class="id" title="var">i</span> = <span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>}.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [| <span class="id" title="var">n</span> <span class="id" title="var">IH</span>].<br/>
* <span class="id" title="tactic">∃</span> 0. <span class="id" title="tactic">split</span>; <span class="id" title="tactic">reflexivity</span>.<br/>
* <span class="id" title="tactic">destruct</span> <span class="id" title="var">IH</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">i</span> [<span class="id" title="var">IH1</span> <span class="id" title="var">IH2</span>]].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="var">arrayMax</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> (<span class="id" title="var">max_dec</span> (<span class="id" title="var">arrayMax</span> <span class="id" title="var">n</span>) (<span class="id" title="var">array</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>))) <span class="id" title="keyword">as</span> [<span class="id" title="var">H</span> | <span class="id" title="var">H</span>];<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="tactic">∃</span> <span class="id" title="var">i</span> | <span class="id" title="tactic">∃</span> (<span class="id" title="var">S</span> <span class="id" title="var">n</span>)]; (<span class="id" title="tactic">split</span>; [<span class="id" title="tactic">auto</span> | <span class="id" title="tactic">congruence</span>]).<br/>
<span class="id" title="keyword">Defined</span>.<br/>

<br/>
</div>

<div class="doc">
Конструктивные теоремы должны заканчиваться с помощью <span class="inlinecode"><span class="id" title="keyword">Defined</span></span>,
а не <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ArrayMax</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab3"></a><h2 class="section">Тестирование функции <span class="inlinecode"><span class="id" title="var">arrayMax</span></span></h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">arrayMax</span>.<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="var">arrayMaxSpec1</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <span class="id" title="var">ArrayTest</span>.<br/>

<br/>
</div>

<div class="doc">
Заведём переменную, про которую больше ничего не известно.
Она будет выполнять роль неопределенного значения. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variable</span> <span class="id" title="var">undef</span> : <span class="id" title="var">nat</span>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">array</span> (<span class="id" title="var">n</span> : <span class="id" title="var">nat</span>) : <span class="id" title="var">nat</span> :=<br/>
<span class="id" title="keyword">match</span> <span class="id" title="var">n</span> <span class="id" title="keyword">with</span><br/>
| 0 ⇒ 4<br/>
| 1 ⇒ 2<br/>
| 2 ⇒ 7<br/>
| 3 ⇒ 2<br/>
| 4 ⇒ 0<br/>
| <span class="id" title="var">_</span> ⇒ <span class="id" title="var">undef</span><br/>
<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
max index 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">mi</span> := 4.<br/>

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">arrayMax</span> <span class="id" title="var">array</span> <span class="id" title="var">mi</span>.<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">arrayMax'</span> <span class="id" title="var">array</span> <span class="id" title="var">mi</span>.<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">arrayMaxTail</span> <span class="id" title="var">array</span> <span class="id" title="var">mi</span>.<br/>

<br/>
</div>

<div class="doc">
Проверим работу <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2_constr</span></span> как функции, которая возвращает
индекс, где находится максимум. Библиотечная функция <span class="inlinecode"><span class="id" title="var">proj1_sig</span></span> <span class="inlinecode"><span class="id" title="var">p</span></span> возвращает
первую компоненту пары <span class="inlinecode"><span class="id" title="var">p</span></span> типа <span class="inlinecode">{<span class="id" title="var">i</span></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">nat</span></span> <span class="inlinecode">|</span> <span class="inlinecode">...}</span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Compute</span> <span class="id" title="var">proj1_sig</span> (<span class="id" title="var">arrayMaxSpec2_constr</span> <span class="id" title="var">array</span> <span class="id" title="var">mi</span>).<br/>

<br/>
</div>

<div class="doc">
Возвращает <span class="inlinecode">2</span>, так как <span class="inlinecode"><span class="id" title="var">array</span></span> <span class="inlinecode">2</span> <span class="inlinecode">=</span> <span class="inlinecode">7</span>.

<div class="paragraph"> </div>

В случае функции <span class="inlinecode"><span class="id" title="var">arrayMax</span></span> мы сначала написали функцию, а потом
доказали, что она соответствует своей спецификации. Использование
конструктивных доказательств, таких как <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2_constr</span></span>, в
качестве программ согласно соответствию Карри-Говарда является еще
одним способом получить верифицированную программу. Такая программа
является правильной по построению. Таким образом, вместо написания
программы можно составить конструктивное доказательство существования
необходимого объекта. При этом программирование и доказательство
теорем сливаются в одно. В некотором точном смысле конструктивное
доказательство — это программа, которая переделывает свидетельство
того, что дано, в свидетельство того, что нужно доказать.

<div class="paragraph"> </div>

Нормализация в Coq терма-доказательства утверждения о существовании
какого-то объекта является не очень эффективным способом построения
этого объекта, потому что значительная часть терма посвящена
доказательству того, что объект обладает нужным свойством. Это
доказательство затем отбрасывается. Coq умеет преобразовывать
доказательства в программы на языках функционального программирования
OCaml, Haskell и Scheme. При этом неконструктивные части
доказательства удаляются. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">ArrayTest</span>.<br/>

<br/>
</div>

<div class="doc">
Извлечем программу на Scheme из доказательства <span class="inlinecode"><span class="id" title="var">arrayMaxSpec2_constr</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Extraction</span>.<br/>

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">Language</span> <span class="id" title="keyword">Scheme</span>.<br/>

<br/>
<span class="id" title="keyword">Extraction</span> <span class="id" title="var">arrayMaxSpec2_constr</span>.<br/>

<br/>
</div>

<div class="doc">
Извлеченный код.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">(<span class="id" title="var">define</span> <span class="id" title="var">arrayMaxSpec2_constr</span> (<span class="id" title="var">lambdas</span> (<span class="id" title="var">array</span> <span class="id" title="var">n</span>)<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="var">O</span>) `(<span class="id" title="var">O</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="var">S</span> <span class="id" title="var">n0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">let</span> ((<span class="id" title="var">s</span> (@ <span class="id" title="var">max_dec0</span> (@ <span class="id" title="var">arrayMax</span> <span class="id" title="var">array</span> <span class="id" title="var">n0</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">array</span> `(<span class="id" title="var">S</span> ,<span class="id" title="var">n0</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="var">Left</span>) (@ <span class="id" title="var">arrayMaxSpec2_constr</span> <span class="id" title="var">array</span> <span class="id" title="var">n0</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((<span class="id" title="var">Right</span>) `(<span class="id" title="var">S</span> ,<span class="id" title="var">n0</span>))))))))
<div class="paragraph"> </div>

</span>
</div>
<div class="code">
</div>
<hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>